% LPS visualisation for self-driving car
% Define street as: street(StreetName, coordinate(X, Y), Width, Height, Number_of_lane) eg: street(piccadillyRoad, coordinate(9, 9), 80, 70, 2)
% Define location of car as location(Name_of_car, coordinate(X, Y), Direction) eg: location(yourCar, coordinate(9, 9), eastward)
% Define traffic light as trafficLight(coordinate(X, Y), Working_status, Color, FacingDirection) eg: trafficLight(coordinate(2, 2), on, Red, eastward)

% we assume the destination is reachable
% and car length is 40 x 40 based on the image
% speed is 5 unit per cycle.
maxTime(100).
cycleInterval(50).

loadModule('../scripts/module.js').

fluents([
  stopped(VehicleName),
  moving(VehicleName),
  coordinate(X, Y),
  dir(A,B),
  location(VehicleName, coordinate(X, Y), dir(A,B)),
  trafficLight(coordinate(X, Y), Color, FacingDirection,Street),
  street(StreetName, coordinate(X, Y), Width, Height, Number_of_lane, Priority),
  roundabout(StreetName, coordinate(X, Y),Radius1,Radius2,Radius3),
  goal(VehicleName,coordinate(X, Y))

]).

% % events will reserved for user placing blocked item.
% events ([
%   placingBlockedItem()
% ]).

actions ([
  step(Vehicle, NextPlace),
  turn(Vehicle, NewHeading),
  arrive(Vehicle),
  changeTrafficLight(Place,Color)
]).

initially([
  %  stopped(car0),
  %  stopped(car1),
  %  stopped(car2),


 %  normal start one on the mainstreet and other on the southStreet
 % carA wants to go straight from mainStreet, carB want to turn left from southStreet
  location(car0, coordinate(410, 513), dir(0,-1)),

  goal(car0,coordinate(495, 610)),
  moving(car0)


  % % a stoped car near  another car
  %  moving(car0),
  %  stopped(car1),
  %  location(car0, coordinate(145, 475), eastward),
  %  location(car1, coordinate(200, 525), westward),
  %  goal(car0,coordinate(980, 475)),
  %  goal(car1,coordinate(200, 525)),
]).

% define the street coordinate facts.
street(northStreet , coordinate(470, 120), 50, 300, 2,0).

street(northStreet , coordinate(520, 120), 50, 300, 2,0).

street(mainStreet , coordinate(100, 450), 300, 50, 2,1).

street(mainStreet , coordinate(100, 500), 300, 50, 2,1).

street(mainStreet , coordinate(640, 450), 500, 50, 2,1).

street(mainStreet , coordinate(640, 500), 500, 50, 2,1).

street(southStreet , coordinate(470, 580), 50, 300, 2,0).

street(southStreet , coordinate(520, 580), 50, 300, 2,0).
%
roundabout(r1, coordinate(520, 500),40,90,140).
% roundabout(r1, coordinate(520, 500),40,300,700).

roundJunction(rJuntion1,coordinate(500, 500)).
roundJunction(rJuntion2,coordinate(500, 500)).
roundJunction(rJuntion3,coordinate(500, 500)).
roundJunction(rJuntion4,coordinate(500, 500)).


cloud(coordinate(140,100)).
cloud(coordinate(250,90)).
cloud(coordinate(300,120)).

cloud(coordinate(640,100)).
cloud(coordinate(750,90)).
cloud(coordinate(800,120)).




goal(Vehicle,coordinate(A, B)) from _ to T,
location(Vehicle, coordinate(X, Y), _), abs(A-X)<10, abs(B-Y)<10,moving(Vehicle) at T ->
  % testPrint(Vehicle+ ' we have arrived'),
  arrive(Vehicle) at T.


goal(Vehicle,coordinate(A, B)) from _ to T,
location(Vehicle, coordinate(X, Y), Direction),
  moving(Vehicle) at T ->
    % need to find the right direction here
    % driving forward
    % testPrint(Vehicle+' '+X+' '+Y+' Direction '+Direction + '----------------Reactive rule----------------'),
    direction(Vehicle) at T.


goal(Vehicle,coordinate(A, B)) from T to T1,
location(Vehicle, coordinate(X, Y), Direction),
  moving(Vehicle) at T1 ->

    % testPrint(Vehicle + " start driving"),
    drive(Vehicle) from T1 to _.


% ---------------------------------------------------------------------------------------------
% the case where car is not at t junction.
direction(Vehicle) at T<-
  % testPrint('checking in roundabout or not ?'),
  location(Vehicle, coordinate(X, Y), _) at T,
  roundabout(Name, coordinate(C1, C2),R1,R2,R3),
  notAtRoundabout(X,Y,C1,C2,R3).



notAtRoundabout(X,Y,C1,C2,R3)<-
  PowX = (X-C1)**2,
  PowY = (Y-C2)**2,
  Dis = sqrt(PowX+PowY),
  % testPrint('checking Dis: '+ Dis+" "+R3),
  Dis > R3.

  % this is the weridest bug I have ever found in LPS interpreter. came from not
  % where @< does't work some times.


% you only turn when you are in the middle of the juction.
direction(Vehicle) at T<-
  % testPrint('moving! around!!'),
  location(Vehicle, _, dir(A,B)),
  goal(Vehicle,coordinate(K, P)),
  % COS60 = 0.5,
  % COS60 = A*X + B*Y.
  % 1 = X**2 + Y**2,
  Theta = pi/36,
  X = A*cos(Theta) - B*sin(Theta),
  Y = B*cos(Theta) + A*sin(Theta),
  % testPrint(Vehicle +' turing '+X+" "+Y ),
    turn(Vehicle,dir(X,Y)) at T.


% ---------------------------------------------------------------------------------------------


% drive macro event.
drive(Vehicle) from T to T1 <-
  location(Vehicle, coordinate(X, Y), dir(A,B)),
  AA = 10 * A,
  NewX = X + AA,
  BB = 10 * B,
  NewY = Y + BB,
  % testPrint("old loca: ("+ X+" "+Y+") New loca: ("+ NewX+" "+NewY+") Dir: ("+A+","+B+")"),
  NextPlace = coordinate(NewX, NewY),
  % testPrint(Vehicle+ ' move northward'),
  step(Vehicle, NextPlace) at T1.


updates(step(Vehicle, NextPlace), location(Vehicle, OldPlace,Direction),  location(Vehicle, NextPlace, Direction)).

updates(turn(Vehicle, NewHeading) , location(Vehicle, Place, OldHeading), location(Vehicle, Place, NewHeading)).

terminates(arrive(Vehicle), moving(Vehicle)).
initiates(arrive(Vehicle), stopped(Vehicle)).
% you  can not move (x++) if you are not facing eastward
